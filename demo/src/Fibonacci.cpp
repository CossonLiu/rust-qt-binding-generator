/* generated by rust_qt_binding_generator */
#include "Fibonacci.h"

namespace {
    struct qbytearray_t {
    private:
        const char* data;
        int len;
    public:
        qbytearray_t(const QByteArray& v):
            data(v.data()),
            len(v.size()) {
        }
        operator QByteArray() const {
            return QByteArray(data, len);
        }
    };
    struct qstring_t {
    private:
        const void* data;
        int len;
    public:
        qstring_t(const QString& v):
            data(static_cast<const void*>(v.utf16())),
            len(v.size()) {
        }
        operator QString() const {
            return QString::fromUtf8(static_cast<const char*>(data), len);
        }
    };
    struct qmodelindex_t {
        int row;
        quintptr id;
    };
}
typedef void (*qstring_set)(QString*, qstring_t*);
void set_qstring(QString* v, qstring_t* val) {
    *v = *val;
}
typedef void (*qbytearray_set)(QByteArray*, qbytearray_t*);
void set_qbytearray(QByteArray* v, qbytearray_t* val) {
    *v = *val;
}

extern "C" {
    Fibonacci::Private* fibonacci_new(Fibonacci*, void (*)(Fibonacci*), void (*)(Fibonacci*));
    void fibonacci_free(Fibonacci::Private*);
    quint32 fibonacci_input_get(const Fibonacci::Private*);
    void fibonacci_input_set(Fibonacci::Private*, uint);
    quint64 fibonacci_result_get(const Fibonacci::Private*);
    FibonacciList::Private* fibonacci_list_new(FibonacciList*,
        void (*)(const FibonacciList*),
        void (*)(FibonacciList*),
        void (*)(FibonacciList*),
        void (*)(FibonacciList*, int, int),
        void (*)(FibonacciList*),
        void (*)(FibonacciList*, int, int),
        void (*)(FibonacciList*));
    void fibonacci_list_free(FibonacciList::Private*);
};
Fibonacci::Fibonacci(QObject *parent):
    QObject(parent),
    d(fibonacci_new(this,
        [](Fibonacci* o) { emit o->inputChanged(); },
        [](Fibonacci* o) { emit o->resultChanged(); })) {}

Fibonacci::~Fibonacci() {
    fibonacci_free(d);
}
quint32 Fibonacci::input() const
{
    return fibonacci_input_get(d);
}
void Fibonacci::setInput(uint v) {
    fibonacci_input_set(d, v);
}
quint64 Fibonacci::result() const
{
    return fibonacci_result_get(d);
}
FibonacciList::FibonacciList(QObject *parent):
    QAbstractItemModel(parent),
    d(fibonacci_list_new(this,
        [](const FibonacciList* o) {
            emit o->newDataReady(QModelIndex());
        },
        [](FibonacciList* o) {
            o->beginResetModel();
        },
        [](FibonacciList* o) {
            o->endResetModel();
        },
        [](FibonacciList* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](FibonacciList* o) {
            o->endInsertRows();
        },
        [](FibonacciList* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](FibonacciList* o) {
            o->endRemoveRows();
        }
    )) {
    connect(this, &FibonacciList::newDataReady, this, [this](const QModelIndex& i) {
        fetchMore(i);
    }, Qt::QueuedConnection);
}


FibonacciList::~FibonacciList() {
    fibonacci_list_free(d);
}
extern "C" {
    quint64 fibonacci_list_data_result(const FibonacciList::Private*, int);
    void fibonacci_list_sort(FibonacciList::Private*, int column, Qt::SortOrder order = Qt::AscendingOrder);

    int fibonacci_list_row_count(const FibonacciList::Private*);
    bool fibonacci_list_can_fetch_more(const FibonacciList::Private*);
    void fibonacci_list_fetch_more(FibonacciList::Private*);
}
int FibonacciList::columnCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : 1;
}

bool FibonacciList::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int FibonacciList::rowCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : fibonacci_list_row_count(d);
}

QModelIndex FibonacciList::index(int row, int column, const QModelIndex &parent) const
{
    if (!parent.isValid() && column == 0) {
        return createIndex(row, 0, (quintptr)0);
    }
    return QModelIndex();
}

QModelIndex FibonacciList::parent(const QModelIndex &) const
{
    return QModelIndex();
}

bool FibonacciList::canFetchMore(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : fibonacci_list_can_fetch_more(d);
}

void FibonacciList::fetchMore(const QModelIndex &parent)
{
    if (!parent.isValid()) {
        fibonacci_list_fetch_more(d);
    }
}

void FibonacciList::sort(int column, Qt::SortOrder order)
{
    fibonacci_list_sort(d, column, order);
}
Qt::ItemFlags FibonacciList::flags(const QModelIndex &i) const
{
    return QAbstractItemModel::flags(i);
}
QVariant FibonacciList::data(const QModelIndex &index, int role) const
{
    QVariant v;
    QString s;
    QByteArray b;
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::DisplayRole:
            v.setValue<quint64>(fibonacci_list_data_result(d, index.row()));
            break;
        }
        break;
    }
    return v;
}
QHash<int, QByteArray> FibonacciList::roleNames() const {
    QHash<int, QByteArray> names;
    names.insert(Qt::DisplayRole, "result");
    return names;
}

