/* generated by rust_qt_binding_generator */
#include "Tree.h"

namespace {
    template <typename T>
    struct option {
    public:
        T value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant(value);
            }
            return QVariant();
        }
    };
    struct qbytearray_t {
    private:
        const char* data;
        int len;
    public:
        qbytearray_t(const QByteArray& v):
            data(v.data()),
            len(v.size()) {
        }
        operator QByteArray() const {
            return QByteArray(data, len);
        }
    };
    struct qstring_t {
    private:
        const void* data;
        int len;
    public:
        qstring_t(const QString& v):
            data(static_cast<const void*>(v.utf16())),
            len(v.size()) {
        }
        operator QString() const {
            return QString::fromUtf8(static_cast<const char*>(data), len);
        }
    };
    struct qmodelindex_t {
        int row;
        quintptr id;
    };
    inline void treePathChanged(Tree* o)
    {
        emit o->pathChanged();
    }

}
typedef void (*qstring_set)(QString*, qstring_t*);
void set_qstring(QString* v, qstring_t* val) {
    *v = *val;
}
typedef void (*qbytearray_set)(QByteArray*, qbytearray_t*);
void set_qbytearray(QByteArray* v, qbytearray_t* val) {
    *v = *val;
}
extern "C" {
    void tree_data_file_icon(const Tree::Private*, quintptr, QByteArray*, qbytearray_set);
    void tree_data_file_name(const Tree::Private*, quintptr, QString*, qstring_set);
    void tree_data_file_path(const Tree::Private*, quintptr, QString*, qstring_set);
    qint32 tree_data_file_permissions(const Tree::Private*, quintptr);
    option<quint64> tree_data_file_size(const Tree::Private*, quintptr);
    qint32 tree_data_file_type(const Tree::Private*, quintptr);
    void tree_sort(Tree::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);

    int tree_row_count(const Tree::Private*, quintptr, bool);
    bool tree_can_fetch_more(const Tree::Private*, quintptr, bool);
    void tree_fetch_more(Tree::Private*, quintptr, bool);
    quintptr tree_index(const Tree::Private*, quintptr, bool, int);
    qmodelindex_t tree_parent(const Tree::Private*, quintptr);
    int tree_row(const Tree::Private*, quintptr);
}
int Tree::columnCount(const QModelIndex &) const
{
    return 5;
}

bool Tree::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int Tree::rowCount(const QModelIndex &parent) const
{
    if (parent.isValid() && parent.column() != 0) {
        return 0;
    }
    return tree_row_count(m_d, parent.internalId(), parent.isValid());
}

QModelIndex Tree::index(int row, int column, const QModelIndex &parent) const
{
    if (row < 0 || column < 0 || column >= 5) {
        return QModelIndex();
    }
    if (parent.isValid() && parent.column() != 0) {
        return QModelIndex();
    }
    if (row >= rowCount(parent)) {
        return QModelIndex();
    }
    const quintptr id = tree_index(m_d, parent.internalId(), parent.isValid(), row);
    return createIndex(row, column, id);
}

QModelIndex Tree::parent(const QModelIndex &index) const
{
    if (!index.isValid()) {
        return QModelIndex();
    }
    const qmodelindex_t parent = tree_parent(m_d, index.internalId());
    return parent.row >= 0 ?createIndex(parent.row, 0, parent.id) :QModelIndex();
}

bool Tree::canFetchMore(const QModelIndex &parent) const
{
    if (parent.isValid() && parent.column() != 0) {
        return false;
    }
    return tree_can_fetch_more(m_d, parent.internalId(), parent.isValid());
}

void Tree::fetchMore(const QModelIndex &parent)
{
    tree_fetch_more(m_d, parent.internalId(), parent.isValid());
}

void Tree::sort(int column, Qt::SortOrder order)
{
    tree_sort(m_d, column, order);
}
Qt::ItemFlags Tree::flags(const QModelIndex &i) const
{
    auto flags = QAbstractItemModel::flags(i);
    return flags;
}
QVariant Tree::data(const QModelIndex &index, int role) const
{
    QVariant v;
    Q_ASSERT(rowCount(index.parent()) > index.row());
    QString s;
    QByteArray b;
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::DecorationRole:
        case Qt::UserRole + 0:
            tree_data_file_icon(m_d, index.internalId(), &b, set_qbytearray);
            if (!b.isNull()) v.setValue<QByteArray>(b);
            break;
        case Qt::DisplayRole:
        case Qt::UserRole + 1:
            tree_data_file_name(m_d, index.internalId(), &s, set_qstring);
            if (!s.isNull()) v.setValue<QString>(s);
            break;
        case Qt::UserRole + 2:
            tree_data_file_path(m_d, index.internalId(), &s, set_qstring);
            if (!s.isNull()) v.setValue<QString>(s);
            break;
        case Qt::UserRole + 3:
            v = tree_data_file_permissions(m_d, index.internalId());
            break;
        case Qt::UserRole + 4:
            v = tree_data_file_size(m_d, index.internalId());
            break;
        case Qt::UserRole + 5:
            v = tree_data_file_type(m_d, index.internalId());
            break;
        }
        break;
    case 1:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::UserRole + 4:
            v = tree_data_file_size(m_d, index.internalId());
            break;
        }
        break;
    case 2:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::UserRole + 2:
            tree_data_file_path(m_d, index.internalId(), &s, set_qstring);
            if (!s.isNull()) v.setValue<QString>(s);
            break;
        }
        break;
    case 3:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::UserRole + 3:
            v = tree_data_file_permissions(m_d, index.internalId());
            break;
        }
        break;
    case 4:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::UserRole + 5:
            v = tree_data_file_type(m_d, index.internalId());
            break;
        }
        break;
    }
    return v;
}
QHash<int, QByteArray> Tree::roleNames() const {
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
    names.insert(Qt::UserRole + 0, "fileIcon");
    names.insert(Qt::UserRole + 1, "fileName");
    names.insert(Qt::UserRole + 2, "filePath");
    names.insert(Qt::UserRole + 3, "filePermissions");
    names.insert(Qt::UserRole + 4, "fileSize");
    names.insert(Qt::UserRole + 5, "fileType");
    return names;
}
bool Tree::setData(const QModelIndex &index, const QVariant &value, int role)
{
    bool set = false;
    if (set) {
        emit dataChanged(index, index, QVector<int>() << role);
    }
    return set;
}
extern "C" {
    Tree::Private* tree_new(Tree*, void (*)(Tree*),
        void (*)(const Tree*, quintptr, bool),
        void (*)(Tree*, quintptr, quintptr),
        void (*)(Tree*),
        void (*)(Tree*),
        void (*)(Tree*, option<quintptr>, int, int),
        void (*)(Tree*),
        void (*)(Tree*, option<quintptr>, int, int),
        void (*)(Tree*));
    void tree_free(Tree::Private*);
    void tree_path_get(const Tree::Private*, QString*, qstring_set);
    void tree_path_set(Tree::Private*, qstring_t);
    void tree_path_set_none(Tree::Private*);
};

Tree::Tree(bool /*owned*/, QObject *parent):
    QAbstractItemModel(parent),
    m_d(0),
    m_ownsPrivate(false)
{
}

Tree::Tree(QObject *parent):
    QAbstractItemModel(parent),
    m_d(tree_new(this,
        treePathChanged,
        [](const Tree* o, quintptr id, bool valid) {
            if (valid) {
                int row = tree_row(o->m_d, id);
                emit o->newDataReady(o->createIndex(row, 0, id));
            } else {
                emit o->newDataReady(QModelIndex());
            }
        },
        [](Tree* o, quintptr first, quintptr last) {
            quintptr frow = tree_row(o->m_d, first);
            quintptr lrow = tree_row(o->m_d, first);
            o->dataChanged(o->createIndex(frow, 0, first),
                       o->createIndex(lrow, 4, last));
        },
        [](Tree* o) {
            o->beginResetModel();
        },
        [](Tree* o) {
            o->endResetModel();
        },
        [](Tree* o, option<quintptr> id, int first, int last) {
            if (id.some) {
                int row = tree_row(o->m_d, id.value);
                o->beginInsertRows(o->createIndex(row, 0, id.value), first, last);
            } else {
                o->beginInsertRows(QModelIndex(), first, last);
            }
        },
        [](Tree* o) {
            o->endInsertRows();
        },
        [](Tree* o, option<quintptr> id, int first, int last) {
            if (id.some) {
                int row = tree_row(o->m_d, id.value);
                o->beginRemoveRows(o->createIndex(row, 0, id.value), first, last);
            } else {
                o->beginRemoveRows(QModelIndex(), first, last);
            }
        },
        [](Tree* o) {
            o->endRemoveRows();
        }
)),
    m_ownsPrivate(true)
{
    connect(this, &Tree::newDataReady, this, [this](const QModelIndex& i) {
        fetchMore(i);
    }, Qt::QueuedConnection);
}

Tree::~Tree() {
    if (m_ownsPrivate) {
        tree_free(m_d);
    }
}
QString Tree::path() const
{
    QString v;
    tree_path_get(m_d, &v, set_qstring);
    return v;
}
void Tree::setPath(const QString& v) {
    if (v.isNull()) {
        tree_path_set_none(m_d);
    } else {
        tree_path_set(m_d, v);
    }
}
