/* generated by rust_qt_binding_generator */
#![allow(unknown_lints)]
#![allow(mutex_atomic, needless_pass_by_value)]
use libc::{c_int, c_void};
use types::*;
use std::sync::{Arc, Mutex};
use std::ptr::null;

use implementation::*;

pub struct ObjectQObject {}

#[derive (Clone)]
pub struct ObjectEmitter {
    qobject: Arc<Mutex<*const ObjectQObject>>,
    value_changed: fn(*const ObjectQObject),
}

unsafe impl Send for ObjectEmitter {}

impl ObjectEmitter {
    fn clear(&self) {
        *self.qobject.lock().unwrap() = null();
    }
    pub fn value_changed(&self) {
        let ptr = *self.qobject.lock().unwrap();
        if !ptr.is_null() {
            (self.value_changed)(ptr);
        }
    }
}

pub trait ObjectTrait {
    fn create(emit: ObjectEmitter) -> Self;
    fn emit(&self) -> &ObjectEmitter;
    fn get_value(&self) -> Variant;
    fn set_value(&mut self, value: Variant);
}

#[no_mangle]
pub extern "C" fn object_new(qobject: *const ObjectQObject,
        value_changed: fn(*const ObjectQObject))
        -> *mut Object {
    let emit = ObjectEmitter {
        qobject: Arc::new(Mutex::new(qobject)),
        value_changed: value_changed,
    };
    let d = Object::create(emit);
    Box::into_raw(Box::new(d))
}

#[no_mangle]
pub unsafe extern "C" fn object_free(ptr: *mut Object) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn object_value_get(ptr: *const Object,
        p: *mut c_void,
        set: fn(*mut c_void, QVariant)) {
    let data = (&*ptr).get_value();
    set(p, QVariant::from(&data));
}

#[no_mangle]
pub unsafe extern "C" fn object_value_set(ptr: *mut Object, v: QVariant) {
    (&mut *ptr).set_value(v.convert());
}
