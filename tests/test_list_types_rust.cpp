/* generated by rust_qt_binding_generator */
#include "test_list_types_rust.h"

namespace {

    struct option_bool {
    public:
        bool value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant::fromValue(value);
            }
            return QVariant();
        }
    };
    static_assert(std::is_pod<option_bool>::value, "option_bool must be a POD type.");

    struct option_quintptr {
    public:
        quintptr value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant::fromValue(value);
            }
            return QVariant();
        }
    };
    static_assert(std::is_pod<option_quintptr>::value, "option_quintptr must be a POD type.");

    typedef void (*qstring_set)(QString* val, const char* utf8, int nbytes);
    void set_qstring(QString* val, const char* utf8, int nbytes) {
        *val = QString::fromUtf8(utf8, nbytes);
    }

    typedef void (*qbytearray_set)(QByteArray* val, const char* bytes, int nbytes);
    void set_qbytearray(QByteArray* v, const char* bytes, int nbytes) {
        if (v->isNull() && nbytes == 0) {
            *v = QByteArray(bytes, nbytes);
        } else {
            v->truncate(0);
            v->append(bytes, nbytes);
        }
    }

    struct qmodelindex_t {
        int row;
        quintptr id;
    };
    inline QVariant cleanNullQVariant(const QVariant& v) {
        return (v.isNull()) ?QVariant() :v;
    }
}
extern "C" {
    bool list_data_boolean(const List::Private*, int);
    bool list_set_data_boolean(List::Private*, int, bool);
    void list_data_bytearray(const List::Private*, int, QByteArray*, qbytearray_set);
    bool list_set_data_bytearray(List::Private*, int, const char* s, int len);
    float list_data_f32(const List::Private*, int);
    bool list_set_data_f32(List::Private*, int, float);
    double list_data_f64(const List::Private*, int);
    bool list_set_data_f64(List::Private*, int, double);
    qint16 list_data_i16(const List::Private*, int);
    bool list_set_data_i16(List::Private*, int, qint16);
    qint32 list_data_i32(const List::Private*, int);
    bool list_set_data_i32(List::Private*, int, qint32);
    qint64 list_data_i64(const List::Private*, int);
    bool list_set_data_i64(List::Private*, int, qint64);
    qint8 list_data_i8(const List::Private*, int);
    bool list_set_data_i8(List::Private*, int, qint8);
    option_bool list_data_optional_boolean(const List::Private*, int);
    bool list_set_data_optional_boolean(List::Private*, int, bool);
    bool list_set_data_optional_boolean_none(List::Private*, int);
    void list_data_optional_bytearray(const List::Private*, int, QByteArray*, qbytearray_set);
    bool list_set_data_optional_bytearray(List::Private*, int, const char* s, int len);
    bool list_set_data_optional_bytearray_none(List::Private*, int);
    void list_data_optional_string(const List::Private*, int, QString*, qstring_set);
    bool list_set_data_optional_string(List::Private*, int, const ushort* s, int len);
    bool list_set_data_optional_string_none(List::Private*, int);
    void list_data_string(const List::Private*, int, QString*, qstring_set);
    bool list_set_data_string(List::Private*, int, const ushort* s, int len);
    uint list_data_u16(const List::Private*, int);
    bool list_set_data_u16(List::Private*, int, uint);
    uint list_data_u32(const List::Private*, int);
    bool list_set_data_u32(List::Private*, int, uint);
    quint64 list_data_u64(const List::Private*, int);
    bool list_set_data_u64(List::Private*, int, quint64);
    quint8 list_data_u8(const List::Private*, int);
    bool list_set_data_u8(List::Private*, int, quint8);
    void list_sort(List::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);

    int list_row_count(const List::Private*);
    bool list_insert_rows(List::Private*, int, int);
    bool list_remove_rows(List::Private*, int, int);
    bool list_can_fetch_more(const List::Private*);
    void list_fetch_more(List::Private*);
}
int List::columnCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : 1;
}

bool List::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int List::rowCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : list_row_count(m_d);
}

bool List::insertRows(int row, int count, const QModelIndex &)
{
    return list_insert_rows(m_d, row, count);
}

bool List::removeRows(int row, int count, const QModelIndex &)
{
    return list_remove_rows(m_d, row, count);
}

QModelIndex List::index(int row, int column, const QModelIndex &parent) const
{
    if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 && column < 1) {
        return createIndex(row, column, (quintptr)row);
    }
    return QModelIndex();
}

QModelIndex List::parent(const QModelIndex &) const
{
    return QModelIndex();
}

bool List::canFetchMore(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : list_can_fetch_more(m_d);
}

void List::fetchMore(const QModelIndex &parent)
{
    if (!parent.isValid()) {
        list_fetch_more(m_d);
    }
}

void List::sort(int column, Qt::SortOrder order)
{
    list_sort(m_d, column, order);
}
Qt::ItemFlags List::flags(const QModelIndex &i) const
{
    auto flags = QAbstractItemModel::flags(i);
    if (i.column() == 0) {
        flags |= Qt::ItemIsEditable;
    }
    return flags;
}

bool List::boolean(int row) const
{
    return list_data_boolean(m_d, row);
}

bool List::setBoolean(int row, bool value)
{
    bool set = false;
    set = list_set_data_boolean(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QByteArray List::bytearray(int row) const
{
    QByteArray b;
    list_data_bytearray(m_d, row, &b, set_qbytearray);
    return b;
}

bool List::setBytearray(int row, const QByteArray& value)
{
    bool set = false;
    set = list_set_data_bytearray(m_d, row, value.data(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

float List::f32(int row) const
{
    return list_data_f32(m_d, row);
}

bool List::setF32(int row, float value)
{
    bool set = false;
    set = list_set_data_f32(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

double List::f64(int row) const
{
    return list_data_f64(m_d, row);
}

bool List::setF64(int row, double value)
{
    bool set = false;
    set = list_set_data_f64(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

qint16 List::i16(int row) const
{
    return list_data_i16(m_d, row);
}

bool List::setI16(int row, qint16 value)
{
    bool set = false;
    set = list_set_data_i16(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

qint32 List::i32(int row) const
{
    return list_data_i32(m_d, row);
}

bool List::setI32(int row, qint32 value)
{
    bool set = false;
    set = list_set_data_i32(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

qint64 List::i64(int row) const
{
    return list_data_i64(m_d, row);
}

bool List::setI64(int row, qint64 value)
{
    bool set = false;
    set = list_set_data_i64(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

qint8 List::i8(int row) const
{
    return list_data_i8(m_d, row);
}

bool List::setI8(int row, qint8 value)
{
    bool set = false;
    set = list_set_data_i8(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QVariant List::optionalBoolean(int row) const
{
    QVariant v;
    v = list_data_optional_boolean(m_d, row);
    return v;
}

bool List::setOptionalBoolean(int row, const QVariant& value)
{
    bool set = false;
    if (value.isNull() || !value.isValid()) {
        set = list_set_data_optional_boolean_none(m_d, row);
    } else {
    if (!value.canConvert(qMetaTypeId<bool>())) {
        return false;
    }
    set = list_set_data_optional_boolean(m_d, row, value.value<bool>());
    }
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QByteArray List::optionalBytearray(int row) const
{
    QByteArray b;
    list_data_optional_bytearray(m_d, row, &b, set_qbytearray);
    return b;
}

bool List::setOptionalBytearray(int row, const QByteArray& value)
{
    bool set = false;
    if (value.isNull()) {
        set = list_set_data_optional_bytearray_none(m_d, row);
    } else {
    set = list_set_data_optional_bytearray(m_d, row, value.data(), value.length());
    }
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QString List::optionalString(int row) const
{
    QString s;
    list_data_optional_string(m_d, row, &s, set_qstring);
    return s;
}

bool List::setOptionalString(int row, const QString& value)
{
    bool set = false;
    if (value.isNull()) {
        set = list_set_data_optional_string_none(m_d, row);
    } else {
    set = list_set_data_optional_string(m_d, row, value.utf16(), value.length());
    }
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QString List::string(int row) const
{
    QString s;
    list_data_string(m_d, row, &s, set_qstring);
    return s;
}

bool List::setString(int row, const QString& value)
{
    bool set = false;
    set = list_set_data_string(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

quint16 List::u16(int row) const
{
    return list_data_u16(m_d, row);
}

bool List::setU16(int row, quint16 value)
{
    bool set = false;
    set = list_set_data_u16(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

quint32 List::u32(int row) const
{
    return list_data_u32(m_d, row);
}

bool List::setU32(int row, quint32 value)
{
    bool set = false;
    set = list_set_data_u32(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

quint64 List::u64(int row) const
{
    return list_data_u64(m_d, row);
}

bool List::setU64(int row, quint64 value)
{
    bool set = false;
    set = list_set_data_u64(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

quint8 List::u8(int row) const
{
    return list_data_u8(m_d, row);
}

bool List::setU8(int row, quint8 value)
{
    bool set = false;
    set = list_set_data_u8(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QVariant List::data(const QModelIndex &index, int role) const
{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::UserRole + 0:
            return QVariant::fromValue(boolean(index.row()));
        case Qt::UserRole + 1:
            return QVariant::fromValue(bytearray(index.row()));
        case Qt::UserRole + 2:
            return QVariant::fromValue(f32(index.row()));
        case Qt::UserRole + 3:
            return QVariant::fromValue(f64(index.row()));
        case Qt::UserRole + 4:
            return QVariant::fromValue(i16(index.row()));
        case Qt::UserRole + 5:
            return QVariant::fromValue(i32(index.row()));
        case Qt::UserRole + 6:
            return QVariant::fromValue(i64(index.row()));
        case Qt::UserRole + 7:
            return QVariant::fromValue(i8(index.row()));
        case Qt::UserRole + 8:
            return optionalBoolean(index.row());
        case Qt::UserRole + 9:
            return cleanNullQVariant(QVariant::fromValue(optionalBytearray(index.row())));
        case Qt::UserRole + 10:
            return cleanNullQVariant(QVariant::fromValue(optionalString(index.row())));
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 11:
            return QVariant::fromValue(string(index.row()));
        case Qt::UserRole + 12:
            return QVariant::fromValue(u16(index.row()));
        case Qt::UserRole + 13:
            return QVariant::fromValue(u32(index.row()));
        case Qt::UserRole + 14:
            return QVariant::fromValue(u64(index.row()));
        case Qt::UserRole + 15:
            return QVariant::fromValue(u8(index.row()));
        }
    }
    return QVariant();
}

QHash<int, QByteArray> List::roleNames() const {
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
    names.insert(Qt::UserRole + 0, "boolean");
    names.insert(Qt::UserRole + 1, "bytearray");
    names.insert(Qt::UserRole + 2, "f32");
    names.insert(Qt::UserRole + 3, "f64");
    names.insert(Qt::UserRole + 4, "i16");
    names.insert(Qt::UserRole + 5, "i32");
    names.insert(Qt::UserRole + 6, "i64");
    names.insert(Qt::UserRole + 7, "i8");
    names.insert(Qt::UserRole + 8, "optionalBoolean");
    names.insert(Qt::UserRole + 9, "optionalBytearray");
    names.insert(Qt::UserRole + 10, "optionalString");
    names.insert(Qt::UserRole + 11, "string");
    names.insert(Qt::UserRole + 12, "u16");
    names.insert(Qt::UserRole + 13, "u32");
    names.insert(Qt::UserRole + 14, "u64");
    names.insert(Qt::UserRole + 15, "u8");
    return names;
}
QVariant List::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation != Qt::Horizontal) {
        return QVariant();
    }
    return m_headerData.value(qMakePair(section, (Qt::ItemDataRole)role), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}

bool List::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{
    if (orientation != Qt::Horizontal) {
        return false;
    }
    m_headerData.insert(qMakePair(section, (Qt::ItemDataRole)role), value);
    return true;
}

bool List::setData(const QModelIndex &index, const QVariant &value, int role)
{
    if (index.column() == 0) {
        if (role == Qt::UserRole + 0) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setBoolean(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 1) {
            if (value.canConvert(qMetaTypeId<QByteArray>())) {
                return setBytearray(index.row(), value.value<QByteArray>());
            }
        }
        if (role == Qt::UserRole + 2) {
            if (value.canConvert(qMetaTypeId<float>())) {
                return setF32(index.row(), value.value<float>());
            }
        }
        if (role == Qt::UserRole + 3) {
            if (value.canConvert(qMetaTypeId<double>())) {
                return setF64(index.row(), value.value<double>());
            }
        }
        if (role == Qt::UserRole + 4) {
            if (value.canConvert(qMetaTypeId<qint16>())) {
                return setI16(index.row(), value.value<qint16>());
            }
        }
        if (role == Qt::UserRole + 5) {
            if (value.canConvert(qMetaTypeId<qint32>())) {
                return setI32(index.row(), value.value<qint32>());
            }
        }
        if (role == Qt::UserRole + 6) {
            if (value.canConvert(qMetaTypeId<qint64>())) {
                return setI64(index.row(), value.value<qint64>());
            }
        }
        if (role == Qt::UserRole + 7) {
            if (value.canConvert(qMetaTypeId<qint8>())) {
                return setI8(index.row(), value.value<qint8>());
            }
        }
        if (role == Qt::UserRole + 8) {
            return setOptionalBoolean(index.row(), value);
        }
        if (role == Qt::UserRole + 9) {
            if (!value.isValid() || value.isNull() ||value.canConvert(qMetaTypeId<QByteArray>())) {
                return setOptionalBytearray(index.row(), value.value<QByteArray>());
            }
        }
        if (role == Qt::UserRole + 10) {
            if (!value.isValid() || value.isNull() ||value.canConvert(qMetaTypeId<QString>())) {
                return setOptionalString(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 11) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setString(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::UserRole + 12) {
            if (value.canConvert(qMetaTypeId<quint16>())) {
                return setU16(index.row(), value.value<quint16>());
            }
        }
        if (role == Qt::UserRole + 13) {
            if (value.canConvert(qMetaTypeId<quint32>())) {
                return setU32(index.row(), value.value<quint32>());
            }
        }
        if (role == Qt::UserRole + 14) {
            if (value.canConvert(qMetaTypeId<quint64>())) {
                return setU64(index.row(), value.value<quint64>());
            }
        }
        if (role == Qt::UserRole + 15) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setU8(index.row(), value.value<quint8>());
            }
        }
    }
    return false;
}

extern "C" {
    List::Private* list_new(List*,
        void (*)(const List*),
        void (*)(List*, quintptr, quintptr),
        void (*)(List*),
        void (*)(List*),
        void (*)(List*, int, int),
        void (*)(List*),
        void (*)(List*, int, int),
        void (*)(List*));
    void list_free(List::Private*);
};

List::List(bool /*owned*/, QObject *parent):
    QAbstractItemModel(parent),
    m_d(0),
    m_ownsPrivate(false)
{
    initHeaderData();
}

List::List(QObject *parent):
    QAbstractItemModel(parent),
    m_d(list_new(this,
        [](const List* o) {
            emit o->newDataReady(QModelIndex());
        },
        [](List* o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                       o->createIndex(last, 0, last));
        },
        [](List* o) {
            o->beginResetModel();
        },
        [](List* o) {
            o->endResetModel();
        },
        [](List* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](List* o) {
            o->endInsertRows();
        },
        [](List* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](List* o) {
            o->endRemoveRows();
        }
)),
    m_ownsPrivate(true)
{
    connect(this, &List::newDataReady, this, [this](const QModelIndex& i) {
        this->fetchMore(i);
    }, Qt::QueuedConnection);
    initHeaderData();
}

List::~List() {
    if (m_ownsPrivate) {
        list_free(m_d);
    }
}
void List::initHeaderData() {
    m_headerData.insert(qMakePair(0, Qt::DisplayRole), QVariant("string"));
}
