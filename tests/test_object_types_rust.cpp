/* generated by rust_qt_binding_generator */
#include "test_object_types_rust.h"
#include <QModelIndex>

namespace {
    struct qbytearray_t {
    private:
        const char* data;
        int len;
    public:
        qbytearray_t(const QByteArray& v):
            data(v.data()),
            len(v.size()) {
        }
        operator QByteArray() const {
            return QByteArray(data, len);
        }
    };
    struct qstring_t {
    private:
        const void* data;
        int len;
    public:
        qstring_t(const QString& v):
            data(static_cast<const void*>(v.utf16())),
            len(v.size()) {
        }
        operator QString() const {
            return QString::fromUtf8(static_cast<const char*>(data), len);
        }
    };
    struct qmodelindex_t {
        int row;
        int column;
        uint64_t id;
        qmodelindex_t(const QModelIndex& m):
           row(m.row()), column(m.column()), id(m.internalId()) {}
    };
    struct qvariant_t {
        unsigned int type;
        int value;
        const char* data;
    };
    QVariant variant(const qvariant_t& v) {
        switch (v.type) {
            case QVariant::String: return QString::fromUtf8(static_cast<const char*>(v.data), v.value);
            case QVariant::Bool: return QVariant((bool)v.value);
            case QVariant::Int: return QVariant(v.value);
            case QVariant::ByteArray: return QVariant(QByteArray(v.data, v.value));
            default:;
        }
        return QVariant();
    }
    void variant(const QByteArray& v, void* d, void (*set)(void*, qvariant_t)) {
        set(d, {
            .type = QVariant::ByteArray,
            .value = v.length(),
            .data = v.data()
        });
    }
    void variant(const QString& v, void* d, void (*set)(void*, qvariant_t)) {
        set(d, {
            .type = QVariant::String,
            .value = v.size(),
            .data = static_cast<const char*>(static_cast<const void*>(v.utf16()))
        });
    }
    void variant(const QVariant& v, void* d, void (*set)(void*, qvariant_t)) {
        switch (v.type()) {
            case QVariant::Bool:
                set(d, {
                    .type = QVariant::Bool,
                    .value = v.toBool(),
                    .data = 0
                });
                break;
            case QVariant::Int:
                set(d, {
                    .type = QVariant::Int,
                    .value = v.toInt(),
                    .data = 0
                });
                break;
            case QVariant::ByteArray:
                variant(v.toByteArray(), d, set);
                break;
            case QVariant::String:
                variant(v.toString(), d, set);
                break;
            default:
                set(d, {
                    .type = QVariant::Invalid,
                    .value = 0,
                    .data = 0
                });
        }
    }
}
typedef void (*qstring_set)(QString*, qstring_t*);
void set_qstring(QString* v, qstring_t* val) {
    *v = *val;
}
typedef void (*qbytearray_set)(QByteArray*, qbytearray_t*);
void set_qbytearray(QByteArray* v, qbytearray_t* val) {
    *v = *val;
}
typedef void (*qvariant_set)(QVariant*, qvariant_t*);
void set_qvariant(QVariant* v, qvariant_t* val) {
    *v = variant(*val);
}

extern "C" {
    ObjectInterface* object_new(Object*, void (*)(Object*));
    void object_free(ObjectInterface*);
    void object_value_get(ObjectInterface*, QVariant*, qvariant_set);
    void object_value_set(void*, qvariant_t);
};
Object::Object(QObject *parent):
    QObject(parent),
    d(object_new(this,
        [](Object* o) { emit o->valueChanged(); })) {}

Object::~Object() {
    object_free(d);
}
QVariant Object::value() const
{
    QVariant v;
    object_value_get(d, &v, set_qvariant);
    return v;
}
void Object::setValue(const QVariant& v) {
    variant(v, d, object_value_set);
}
